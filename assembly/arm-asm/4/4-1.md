- APCS  

| 寄存器 | APCS名 | APCS角色 | 寄存器 | APCS名 | APCS角色 |
| :---: | :---: | :---: | :---: | :---: | :---: |  
| r0 | a1 | 参数1/整数结果/暂存器 | r2 | a3 | 参数3/暂存器 |
| r1 | a2 | 参数2/暂存器 | r3 | a4 | 参数4/暂存器 |
| r4 | v1 | 寄存器变量1 | r10 | sl/v7 | 静态基址/寄存器变量7 |
| r5 | v2 | 寄存器变量2 | r11 | fp | 帧指针 |
| r6 | v3 | 寄存器变量3 | r12 | ip | 过程内调用暂存寄存器 |
| r7 | v4 | 寄存器变量4 | r13 | sp | 当前栈帧的基址 |
| r8 | v5 | 寄存器变量5 | r14 | lr | 链接地址/暂存寄存器 |
| r9 | sb/v6 | 静态基址/寄存器变量6 | r15 | pc | 程序计数器 |

- 特权模式与异常

> 任何时刻中，ARM都在以下表列出的某一种模式下工作。**CPSR的第五位定义了当前模式，只要发生了中断或异常就会发生一次模式切换。每一种模式都有自己的保存程序状态处理器(SPSR)**

- ARM处理器的操作模式和寄存器组名称

| 操作模式 | CPSR\[4：0\] | 使用 | 寄存器体 |
| :--: | :---: | :---: | :---: |
| 用户 | 10000 | 普通用户模式 | user |
| FIQ | 10001 | 快速中断处理 | _fiq |
| IRQ | 10010 | 中断处理 | _irq |
| SVC | 10011 | 软件中断处理 | _svc |
| 退出 | 10111 | 处理寄存器故障 | _abt |
| 未定义 |11011 | 未定义指令处理 | _und |
| 系统 | 11111 | 操作系统 | user |

- 异常  

> 异常像子程序一样在运行时插入代码中。**通常使用与子程序相同的调用-返回机制。主要区别在于调用地址由处理器硬件提供**  
> 通常，处理器对异常类型进行译码并读取一个指向异常处理例程入口的存储指针。

- **在每一种操作模式下，寄存器r13和r14都会被复制，也就说，当切换到特权模式时，r13和r14在用户模式下的值将不可用。特权模式夹带自己的私有寄存器--r13， r14**

> 异常可分为内部和外部事件引起。外部事件是中断请求(IRQ)，其包括快速中断请求(FIQ)、复位以及页故障  
> 内部异常则包括软件中断以及未定义的指令

- 当发生异常时，ARM处理器会完成当前指令，然后进入异常模式
    - 操作模式改变为异常对应的模式
    - 将紧接在异常发生处之后的指令地址拷贝到r14中，即异常被视作为子程序调用，返回地址在链接寄存器中
    - 将当前处理器状态寄存器(CSPR)的当前值保存在新模式的SPSR中
    - 将CSPR的第七位置1，禁止中断请求。**如果是一个快速请求中断，则将CSPR中的第六位置1禁止其他FIQ请求**
    - 异常表中的每一项都包含异常处理例程中要执行的第一条指令。该指令通常是一个分支操作

- 异常向量

| 异常 | 模式 | 向量地址 |
| :---: | :---: | :---: |
| 复位 | SVC | 0x00000000 |
| 未定义指令 | UND | 0x00000004 |
| 软中断(SWI) | SVC | 0x00000008 |
| 预取退出(从存储器取指令时故障) | Abort | 0x0000000C |
| 数据退出(从存储器取数据时故障) | Abort | 0x00000010 |
| IRQ(普通中断) | IRQ | 0x00000018 | 
| FIQ(快速中断) | FIQ | 0x0000001C |

> 为了异常返回，**必须将定义了异常前模式的信息保存起来(PC和CPSR)。** 
> 如果先恢复PC，那么仍然处于异常状态中  
> 如果先恢复处理器状态，那就不再处于异常处理例程中，没办法恢复CPSR

- 因此，ARM提供了两种返回机制
    - 一种适用于返回地址已经被保存在分体的r14寄存器的情形
    - 一种适用于返回地址已经入栈的情形
- 如果要从返回地址在链接寄存器中的异常返回，可以有如下命令

| 异常类型 | 返回用户模式的指令 |
| :---: | :---: |
| SWI, 未定义指令 | MOVS pc, r14 |
| IRQ, FIQ | SUBS pc, r14, #4 |
| 数据退出以重复故障指令 | SUBS pc, r14, #8 |

- 如果异常处理例程将返回地址拷贝到栈中，必须使用一个有些许不同的机制
- 从pc被保存在栈中的子程序中返回

```arm
LDMFM r13!, { r0-r4, pc }
```

- 如果希望在同一时间将保存在栈中的寄存器取出并恢复CPSR，必须使用下面的特殊形式

```arm
LDMFD r13!, { r0-r4^, pc}
```

- 寄存器列表后面的^符号表明CPSR将在恢复程序寄存器的同事被恢复。**指令不会在恢复程序计数器时修改，因此必须在PC入栈前对其进行修改**

