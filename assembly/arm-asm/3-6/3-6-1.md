- ARM条件执行和分支控制助记符

| 编码 | 助记符 | 分支标志状态 | 执行条件 |
| :---: | :---: | :---: | :---: |
| 0000 | EQ | Z = 1 | 相等则执行 |
| 0001 | NE | Z = 0 | 不等则执行 |
| 0010 | CS | C = 1 | 无符号大于等于 |
| 0011 | CC | C = 0 | 无符号小于 |
| 0100 | MI | N = 1 | 负 |
| 0101 | PL | N = 0 | 正或零 |
| 0110 | VS | V = 1 | 溢出 |
| 0111 | VC | V = 0 | 未溢出 | 
| 1000 | HI | C = 1 && Z = 0 | 无符号大于 |
| 1001 | LS | C = 0 && Z = 1 | 无符号小于等于 |
| 1010 | GE | N = 1 && V = 1(N = 0 && V = 0) | 大于等于 |
| 1011 | LT | N = 1 && V = 0(N = 0 && V = 1) | 小于 |
| 1100 | GT | Z = 0 && N = 1 && V = 1(OR N = 0 && V = 0) | 大于 |
| 1101 | LE | Z = 0 && N = 1 && V = 0(OR N = 0 && V = 1) | 小于等于 |
| 1110 | AL | | 总是(缺省) |
| 1111 | NV | | 从不(保留) |

- 测试与比较指令

> ARM有四条测试比较指令，这些指令会**显式地更新条件码标志**

- 相等测试指令(TEQ)
    - 确定两个操作数是否相等，如果相等则将Z位置置为1，否则清零。**并且，TEQ不影响溢出标志V的状态，而CMP会影响**
- 测试指令(TST)
    - 通过与操作来比较两个操作数，根据测试结果更新标志位

```arm
TST r0, #2_0010000 ; r0与0010000进行与操作，测试第五位的状态
BEQ LowerCase      ; 如果第五位为1，则跳转到小写操作
```

- 比较指令(CMP)
    - 用第一个源操作数减去第二个，然后更新条件码
- 取负比较指令(CMN)
    - 在与第一个操作数进行比较之前，先将第二个源操作数取负。

```arm
CMP r1, r2      
; 实际上就相当于[r1] - [r2] => if eq 0 then Z = 1 else Z = 0
CMN r1, r2      
; 实际上就相当于[r1] - [-r2] => if eq 0 then Z = 1 else Z = 0
```

- 分支与循环结构

- FOR循环

```arm
        MOV r0, #10         ; 设置循环计数器
Loop    code ...            ; 循环体
        SUBS r0, r0, #1     ; 计数器减一，并标志状态
        BNE Loop            ; if r0 == 0 then Post else Loop
        Post Loop...
```

- WHIL循环

```arm
Loop    CMP r0, #0          ; if r0 == 0 then Post else Loop
        BEQ WhileExit
        code ...
        B Loop              ; => while (True)
WhileExit Post Loop
```

- UNTIL循环

```arm
Loop    code ...
        CMP r0, #0          ; if r0 == 0 then Post else Loop
        BNE Loop
        Post Loop...
```

- 条件执行

- IF Z = 1 THEN \[r1\] <- \[r2\] + \[r3\]

```arm
ADDEQ r1, r2, r3
```

-  IF C = 0 THEN \[r1\] <- \[r2\] + \[r3\] $\times 2^{[r4]}$

```arm
ADDCC r1, r2, r3, LSL r4
```

- if (P == Q) X = P - Y;

```arm
CMP r1, r2          
SUBEQ r3, r1, r4
```

- if ((a == b) && (c == d)) e++;

```arm
CMP r0, r1
CMPEQ r2, r3
ADDEQ r4, r4, #1
```

- ARM中的前后递增索引

```arm
LDR r0, [r1, #8]!   
; 这是前置自增，将r1 + 8所指向单元中的字加载到r0 
; 然后 ADD r1, r1, #8

LDR r0, [r1], #8
; 这是后置自增，将r1所指向单元中的字加载到r0
; 然后 ADD r1, r1, #89
```

- **自动索引方式不会带来额外的执行时间**

```arm
Len     EQU 8               ; 数组长度为八个字
        ADR r0, A - 4       ; r0指向A
        ADR r1, B - 4       ; r1指向B
        ADR r2, C - 4       ; r2指向C
        MOV r5, #Len        ; 循环计数器
Loop    LDR r3, [r0, #4]!   ; 加载A
        LDR r4, [r1, #4]!   ; 加载B
        ADD r3, r3, r4      ; 相加
        STR r3, [r2, #4]!   ; 结果存入C中
        SUBS r5, r5, #1
        BNE Loop
```

- LOAD/STORE指令形式化

$$
    LDR | STR\{cond\} \{B\} \quad Rd, [Rn, offset] \{!\} \\
    LDR | STR\{cond\} \{B\} \quad Rd, [Rn], offset
$$

- ARM一条指令分析表

| 31 - 28 | 27 - 26 | 25 | 24 - 20 | 19 - 16 | 15 - 12 | 11 - 0 |  
| :---: | :---: | :---: | :---: | :---: | :---: | :---: |  
| 条件码 | 操作码 | # | 操作码 | S | $r_{源}$ | $r_{dest}$ | 操作数2 |
| | | 0表示立即操作数 | RUBWL | | | 由#决定 |
| | | 1表示移位 | | | | | 

- \#
    - 如果第二十五位为0，则是12位立即数
    - 如果第二十五位为1
        - 基于寄存器的偏移量
        - 立即数位移
        - 由寄存器指定的位移
    - 该位决定了第0~11位的操作数类型
- 第20~24位
    - P：指针调整(前/后递增)
        - 0表示后索引操作，也就是 $[r0], \#1$
        - 1表示前索引操作，也就是 $[r0, \#1]!$
    - U: 指针方向(向上/向下)
        - 0表示递减指针
        - 1表示递增指针
    - B：操作数大小(字节/字)
        - 0表示字访问
        - 1表示字节访问
    - W：指针更新(写回)
        - 0表示不写回调整的指针
        - 1表示写回调整的指针
    - L：数据方向(加载/存储)
        - 0表示保存在存储器中
        - 1表示加载到寄存器上
    - **P和W的存在构成了自动索引方式**

