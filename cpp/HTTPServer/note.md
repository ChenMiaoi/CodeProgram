# 前端：
	1. 对contact页面的表单提交进行一个细化的处理 -> 如何让表单提交后不会转跳到别的页面上？ -> 生成一个提示框，告诉用户 -> 是否提交完成
	2. (选择项)对contact的email表单提交的时候，在页面上提示用户正确的格式 -> 例如: test@126.com等等
	3. (选择项)对contact的phone表单提交的时候，在页面上提示用户必须是自己的phone。 -> 因为我们程序采用的数据库表的结构是unique的。
	4. (选择项)可以想一想首页的DownLoad/ReadMore可以下载什么

# 后端：
	1. C/C++ Socket编程 -> TCP/IP网络编程
		a -> TCP/UDP -> 为什么我们选择了TCP
		b -> TCP/IP的接口
			-> server
				-> socket -> 建立套接字
				-> bind   -> 绑定套接字
				-> listen -> 监听套接字
				-> accept -> 接受client socket发送的请求
					-> 地址复用 -> 因为如果断开之后，由于延迟应答和超时重传机制的存在，会导致socket之间在断开之后，还会向对方发起请求(丢包,各种原因...)，导致你绑定的端口号还是被占用的 -> 如果服务器断开了，没办法马上再次启动，需要等待一段时间才能重启服务器。
			-> client
				-> socket -> 建立套接字
				-> bind   -> 绑定套接字
				-> connect -> 连接server socket
		c -> 什么是三次握手，四次挥手 -> 为什么要这样 -> 三次握手，四次挥手额外机制 -> 确认应答机制 -> 超时重传机制 -> 慢启动机制 -> 延迟应答
		d -> (注意:) ip + port才能确定一台主机上的特定一个软件(进程)
		e -> HTTP协议 -> HTTP的报文格式 -> 响应报头(重要):例如 -> GET HTTP/1.1 OK，Content-Length字段等等 -> POST 和 GET的区别
		f -> TCP/UDP协议 -> TCP/UDP的报文格式
		g -> IP协议 -> IP的报文格式
		h -> MAC帧 -> MAC帧报文格式
	2. C/C++ 进程间通信
		a -> 父子进程 -> fork() -> 如果创建成功，那么返回0以及把子进程的pid交给父进程
		b -> 僵尸进程 -> 为什么会产生僵尸进程 -> 怎么解决
		c -> 孤儿进程(linux特有) -> 为什么会产生孤儿进程 -> 怎么解决
		d -> 父子进程之间有哪些数据是共有的，有哪些是私有的
		e -> 进程替换(非常重要) -> CGI技术 -> 进程间替换的时候，不会将管道的缓冲区进行替换！！！
		f -> 缓冲区 -> 0 1 2 输出缓冲区，输入缓冲区，错误缓冲区
		g -> 管道 -> pipe的创建 -> 进程间父子进程的通信 -> CGI技术 -> 将父进程的读端关闭，子进程的写端关闭
		h -> 重定向技术 -> dup2()
	3. CGI技术
		上网查资料(意义，作用...)
	4. 线程池技术
		a -> 线程和进程的区别，但是在windows上(是有明确定义的线程和进程的), linux上(没有线程和进程的定义，只有task_struct也就是任务，但是可以当作进程线程理解)
		b -> 生产者消费模型 -> 消费者需要多少，生产者就生产多少，如果消费者需求过多，那么生产者就继续生产，如果消费者需求过少，那么生产者就减少生产
		c -> 线程之间有哪些数据是共有的，有哪些是私有的
		d -> 互斥锁 -> lock/unlock -> 条件变量 -> 线程是否休眠/被唤醒
		e -> 任务队列(我们项目中的一个任务队列，依赖线程池来启动 -> 配合单例模式 -> 实现每一个线程启动一个服务)
	5. 设计模式之单例模式
		上网查资料(意义，作用...)
	6. 数据库
		a -> 数据库的意义
		b -> 数据库的使用(略)
		c -> 链接数据库(略)
		d -> 设计表单 -> 和项目关联

